
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.12.1.0
//   Input filename:  benchmark/jsonresume/bond/schema.bond
//   Output filename: schema_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0902
#error This file was generated by a newer version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0c10
#error This file was generated by an older version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace benchmark
{
    
    struct Location
    {
        std::string address;
        std::string postalCode;
        std::string city;
        std::string countryCode;
        std::string region;
        
        Location()
        {
        }

        
        // Compiler generated copy ctor OK
        Location(const Location&) = default;
        
        Location(Location&&) = default;
        
        
        // Compiler generated operator= OK
        Location& operator=(const Location&) = default;
        Location& operator=(Location&&) = default;

        bool operator==(const Location& other) const
        {
            return true
                && (address == other.address)
                && (postalCode == other.postalCode)
                && (city == other.city)
                && (countryCode == other.countryCode)
                && (region == other.region);
        }

        bool operator!=(const Location& other) const
        {
            return !(*this == other);
        }

        void swap(Location& other)
        {
            using std::swap;
            swap(address, other.address);
            swap(postalCode, other.postalCode);
            swap(city, other.city);
            swap(countryCode, other.countryCode);
            swap(region, other.region);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Location& left, ::benchmark::Location& right)
    {
        left.swap(right);
    }

    
    struct Profile
    {
        std::string network;
        std::string username;
        std::string url;
        
        Profile()
        {
        }

        
        // Compiler generated copy ctor OK
        Profile(const Profile&) = default;
        
        Profile(Profile&&) = default;
        
        
        // Compiler generated operator= OK
        Profile& operator=(const Profile&) = default;
        Profile& operator=(Profile&&) = default;

        bool operator==(const Profile& other) const
        {
            return true
                && (network == other.network)
                && (username == other.username)
                && (url == other.url);
        }

        bool operator!=(const Profile& other) const
        {
            return !(*this == other);
        }

        void swap(Profile& other)
        {
            using std::swap;
            swap(network, other.network);
            swap(username, other.username);
            swap(url, other.url);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Profile& left, ::benchmark::Profile& right)
    {
        left.swap(right);
    }

    
    struct Basics
    {
        std::string name;
        std::string label;
        std::string picture;
        std::string email;
        std::string phone;
        std::string website;
        std::string summary;
        ::benchmark::Location location;
        std::list< ::benchmark::Profile> profiles;
        
        Basics()
        {
        }

        
        // Compiler generated copy ctor OK
        Basics(const Basics&) = default;
        
        Basics(Basics&&) = default;
        
        
        // Compiler generated operator= OK
        Basics& operator=(const Basics&) = default;
        Basics& operator=(Basics&&) = default;

        bool operator==(const Basics& other) const
        {
            return true
                && (name == other.name)
                && (label == other.label)
                && (picture == other.picture)
                && (email == other.email)
                && (phone == other.phone)
                && (website == other.website)
                && (summary == other.summary)
                && (location == other.location)
                && (profiles == other.profiles);
        }

        bool operator!=(const Basics& other) const
        {
            return !(*this == other);
        }

        void swap(Basics& other)
        {
            using std::swap;
            swap(name, other.name);
            swap(label, other.label);
            swap(picture, other.picture);
            swap(email, other.email);
            swap(phone, other.phone);
            swap(website, other.website);
            swap(summary, other.summary);
            swap(location, other.location);
            swap(profiles, other.profiles);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Basics& left, ::benchmark::Basics& right)
    {
        left.swap(right);
    }

    
    struct Work
    {
        std::string company;
        std::string position;
        std::string website;
        std::string startDate;
        std::string endDate;
        std::string summary;
        std::list<std::string> highlights;
        
        Work()
        {
        }

        
        // Compiler generated copy ctor OK
        Work(const Work&) = default;
        
        Work(Work&&) = default;
        
        
        // Compiler generated operator= OK
        Work& operator=(const Work&) = default;
        Work& operator=(Work&&) = default;

        bool operator==(const Work& other) const
        {
            return true
                && (company == other.company)
                && (position == other.position)
                && (website == other.website)
                && (startDate == other.startDate)
                && (endDate == other.endDate)
                && (summary == other.summary)
                && (highlights == other.highlights);
        }

        bool operator!=(const Work& other) const
        {
            return !(*this == other);
        }

        void swap(Work& other)
        {
            using std::swap;
            swap(company, other.company);
            swap(position, other.position);
            swap(website, other.website);
            swap(startDate, other.startDate);
            swap(endDate, other.endDate);
            swap(summary, other.summary);
            swap(highlights, other.highlights);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Work& left, ::benchmark::Work& right)
    {
        left.swap(right);
    }

    
    struct Volunteer
    {
        std::string organization;
        std::string position;
        std::string website;
        std::string startDate;
        std::string endDate;
        std::string summary;
        std::list<std::string> highlights;
        
        Volunteer()
        {
        }

        
        // Compiler generated copy ctor OK
        Volunteer(const Volunteer&) = default;
        
        Volunteer(Volunteer&&) = default;
        
        
        // Compiler generated operator= OK
        Volunteer& operator=(const Volunteer&) = default;
        Volunteer& operator=(Volunteer&&) = default;

        bool operator==(const Volunteer& other) const
        {
            return true
                && (organization == other.organization)
                && (position == other.position)
                && (website == other.website)
                && (startDate == other.startDate)
                && (endDate == other.endDate)
                && (summary == other.summary)
                && (highlights == other.highlights);
        }

        bool operator!=(const Volunteer& other) const
        {
            return !(*this == other);
        }

        void swap(Volunteer& other)
        {
            using std::swap;
            swap(organization, other.organization);
            swap(position, other.position);
            swap(website, other.website);
            swap(startDate, other.startDate);
            swap(endDate, other.endDate);
            swap(summary, other.summary);
            swap(highlights, other.highlights);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Volunteer& left, ::benchmark::Volunteer& right)
    {
        left.swap(right);
    }

    
    struct Education
    {
        std::string institution;
        std::string area;
        std::string studyType;
        std::string startDate;
        std::string endDate;
        std::string gpa;
        std::list<std::string> courses;
        
        Education()
        {
        }

        
        // Compiler generated copy ctor OK
        Education(const Education&) = default;
        
        Education(Education&&) = default;
        
        
        // Compiler generated operator= OK
        Education& operator=(const Education&) = default;
        Education& operator=(Education&&) = default;

        bool operator==(const Education& other) const
        {
            return true
                && (institution == other.institution)
                && (area == other.area)
                && (studyType == other.studyType)
                && (startDate == other.startDate)
                && (endDate == other.endDate)
                && (gpa == other.gpa)
                && (courses == other.courses);
        }

        bool operator!=(const Education& other) const
        {
            return !(*this == other);
        }

        void swap(Education& other)
        {
            using std::swap;
            swap(institution, other.institution);
            swap(area, other.area);
            swap(studyType, other.studyType);
            swap(startDate, other.startDate);
            swap(endDate, other.endDate);
            swap(gpa, other.gpa);
            swap(courses, other.courses);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Education& left, ::benchmark::Education& right)
    {
        left.swap(right);
    }

    
    struct Award
    {
        std::string title;
        std::string date;
        std::string awarder;
        std::string summary;
        
        Award()
        {
        }

        
        // Compiler generated copy ctor OK
        Award(const Award&) = default;
        
        Award(Award&&) = default;
        
        
        // Compiler generated operator= OK
        Award& operator=(const Award&) = default;
        Award& operator=(Award&&) = default;

        bool operator==(const Award& other) const
        {
            return true
                && (title == other.title)
                && (date == other.date)
                && (awarder == other.awarder)
                && (summary == other.summary);
        }

        bool operator!=(const Award& other) const
        {
            return !(*this == other);
        }

        void swap(Award& other)
        {
            using std::swap;
            swap(title, other.title);
            swap(date, other.date);
            swap(awarder, other.awarder);
            swap(summary, other.summary);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Award& left, ::benchmark::Award& right)
    {
        left.swap(right);
    }

    
    struct Publication
    {
        std::string name;
        std::string publisher;
        std::string releaseDate;
        std::string website;
        std::string summary;
        
        Publication()
        {
        }

        
        // Compiler generated copy ctor OK
        Publication(const Publication&) = default;
        
        Publication(Publication&&) = default;
        
        
        // Compiler generated operator= OK
        Publication& operator=(const Publication&) = default;
        Publication& operator=(Publication&&) = default;

        bool operator==(const Publication& other) const
        {
            return true
                && (name == other.name)
                && (publisher == other.publisher)
                && (releaseDate == other.releaseDate)
                && (website == other.website)
                && (summary == other.summary);
        }

        bool operator!=(const Publication& other) const
        {
            return !(*this == other);
        }

        void swap(Publication& other)
        {
            using std::swap;
            swap(name, other.name);
            swap(publisher, other.publisher);
            swap(releaseDate, other.releaseDate);
            swap(website, other.website);
            swap(summary, other.summary);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Publication& left, ::benchmark::Publication& right)
    {
        left.swap(right);
    }

    
    struct Skill
    {
        std::string name;
        std::string level;
        std::list<std::string> keywords;
        
        Skill()
        {
        }

        
        // Compiler generated copy ctor OK
        Skill(const Skill&) = default;
        
        Skill(Skill&&) = default;
        
        
        // Compiler generated operator= OK
        Skill& operator=(const Skill&) = default;
        Skill& operator=(Skill&&) = default;

        bool operator==(const Skill& other) const
        {
            return true
                && (name == other.name)
                && (level == other.level)
                && (keywords == other.keywords);
        }

        bool operator!=(const Skill& other) const
        {
            return !(*this == other);
        }

        void swap(Skill& other)
        {
            using std::swap;
            swap(name, other.name);
            swap(level, other.level);
            swap(keywords, other.keywords);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Skill& left, ::benchmark::Skill& right)
    {
        left.swap(right);
    }

    
    struct Language
    {
        std::string language;
        std::string fluency;
        
        Language()
        {
        }

        
        // Compiler generated copy ctor OK
        Language(const Language&) = default;
        
        Language(Language&&) = default;
        
        
        // Compiler generated operator= OK
        Language& operator=(const Language&) = default;
        Language& operator=(Language&&) = default;

        bool operator==(const Language& other) const
        {
            return true
                && (language == other.language)
                && (fluency == other.fluency);
        }

        bool operator!=(const Language& other) const
        {
            return !(*this == other);
        }

        void swap(Language& other)
        {
            using std::swap;
            swap(language, other.language);
            swap(fluency, other.fluency);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Language& left, ::benchmark::Language& right)
    {
        left.swap(right);
    }

    
    struct Interest
    {
        std::string name;
        std::list<std::string> keywords;
        
        Interest()
        {
        }

        
        // Compiler generated copy ctor OK
        Interest(const Interest&) = default;
        
        Interest(Interest&&) = default;
        
        
        // Compiler generated operator= OK
        Interest& operator=(const Interest&) = default;
        Interest& operator=(Interest&&) = default;

        bool operator==(const Interest& other) const
        {
            return true
                && (name == other.name)
                && (keywords == other.keywords);
        }

        bool operator!=(const Interest& other) const
        {
            return !(*this == other);
        }

        void swap(Interest& other)
        {
            using std::swap;
            swap(name, other.name);
            swap(keywords, other.keywords);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Interest& left, ::benchmark::Interest& right)
    {
        left.swap(right);
    }

    
    struct Reference
    {
        std::string name;
        std::string reference;
        
        Reference()
        {
        }

        
        // Compiler generated copy ctor OK
        Reference(const Reference&) = default;
        
        Reference(Reference&&) = default;
        
        
        // Compiler generated operator= OK
        Reference& operator=(const Reference&) = default;
        Reference& operator=(Reference&&) = default;

        bool operator==(const Reference& other) const
        {
            return true
                && (name == other.name)
                && (reference == other.reference);
        }

        bool operator!=(const Reference& other) const
        {
            return !(*this == other);
        }

        void swap(Reference& other)
        {
            using std::swap;
            swap(name, other.name);
            swap(reference, other.reference);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Reference& left, ::benchmark::Reference& right)
    {
        left.swap(right);
    }

    
    struct Main
    {
        ::benchmark::Basics basics;
        std::list< ::benchmark::Work> work;
        std::list< ::benchmark::Volunteer> volunteer;
        std::list< ::benchmark::Education> education;
        std::list< ::benchmark::Award> awards;
        std::list< ::benchmark::Publication> publications;
        std::list< ::benchmark::Skill> skills;
        std::list< ::benchmark::Language> languages;
        std::list< ::benchmark::Interest> interests;
        std::list< ::benchmark::Reference> references;
        
        Main()
        {
        }

        
        // Compiler generated copy ctor OK
        Main(const Main&) = default;
        
        Main(Main&&) = default;
        
        
        // Compiler generated operator= OK
        Main& operator=(const Main&) = default;
        Main& operator=(Main&&) = default;

        bool operator==(const Main& other) const
        {
            return true
                && (basics == other.basics)
                && (work == other.work)
                && (volunteer == other.volunteer)
                && (education == other.education)
                && (awards == other.awards)
                && (publications == other.publications)
                && (skills == other.skills)
                && (languages == other.languages)
                && (interests == other.interests)
                && (references == other.references);
        }

        bool operator!=(const Main& other) const
        {
            return !(*this == other);
        }

        void swap(Main& other)
        {
            using std::swap;
            swap(basics, other.basics);
            swap(work, other.work);
            swap(volunteer, other.volunteer);
            swap(education, other.education);
            swap(awards, other.awards);
            swap(publications, other.publications);
            swap(skills, other.skills);
            swap(languages, other.languages);
            swap(interests, other.interests);
            swap(references, other.references);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Main& left, ::benchmark::Main& right)
    {
        left.swap(right);
    }
} // namespace benchmark
