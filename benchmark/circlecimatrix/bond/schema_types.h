
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.12.1.0
//   Input filename:  benchmark/circlecimatrix/bond/schema.bond
//   Output filename: schema_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0902
#error This file was generated by a newer version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0c10
#error This file was generated by an older version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace benchmark
{
    
    struct Parameters
    {
        std::list<uint8_t> a;
        
        Parameters()
        {
        }

        
        // Compiler generated copy ctor OK
        Parameters(const Parameters&) = default;
        
        Parameters(Parameters&&) = default;
        
        
        // Compiler generated operator= OK
        Parameters& operator=(const Parameters&) = default;
        Parameters& operator=(Parameters&&) = default;

        bool operator==(const Parameters& other) const
        {
            return true
                && (a == other.a);
        }

        bool operator!=(const Parameters& other) const
        {
            return !(*this == other);
        }

        void swap(Parameters& other)
        {
            using std::swap;
            swap(a, other.a);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Parameters& left, ::benchmark::Parameters& right)
    {
        left.swap(right);
    }

    
    struct Matrix
    {
        ::benchmark::Parameters parameters;
        
        Matrix()
        {
        }

        
        // Compiler generated copy ctor OK
        Matrix(const Matrix&) = default;
        
        Matrix(Matrix&&) = default;
        
        
        // Compiler generated operator= OK
        Matrix& operator=(const Matrix&) = default;
        Matrix& operator=(Matrix&&) = default;

        bool operator==(const Matrix& other) const
        {
            return true
                && (parameters == other.parameters);
        }

        bool operator!=(const Matrix& other) const
        {
            return !(*this == other);
        }

        void swap(Matrix& other)
        {
            using std::swap;
            swap(parameters, other.parameters);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Matrix& left, ::benchmark::Matrix& right)
    {
        left.swap(right);
    }

    
    struct M1
    {
        ::benchmark::Matrix matrix;
        
        M1()
        {
        }

        
        // Compiler generated copy ctor OK
        M1(const M1&) = default;
        
        M1(M1&&) = default;
        
        
        // Compiler generated operator= OK
        M1& operator=(const M1&) = default;
        M1& operator=(M1&&) = default;

        bool operator==(const M1& other) const
        {
            return true
                && (matrix == other.matrix);
        }

        bool operator!=(const M1& other) const
        {
            return !(*this == other);
        }

        void swap(M1& other)
        {
            using std::swap;
            swap(matrix, other.matrix);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::M1& left, ::benchmark::M1& right)
    {
        left.swap(right);
    }

    
    struct Job
    {
        ::benchmark::M1 m1;
        
        Job()
        {
        }

        
        // Compiler generated copy ctor OK
        Job(const Job&) = default;
        
        Job(Job&&) = default;
        
        
        // Compiler generated operator= OK
        Job& operator=(const Job&) = default;
        Job& operator=(Job&&) = default;

        bool operator==(const Job& other) const
        {
            return true
                && (m1 == other.m1);
        }

        bool operator!=(const Job& other) const
        {
            return !(*this == other);
        }

        void swap(Job& other)
        {
            using std::swap;
            swap(m1, other.m1);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Job& left, ::benchmark::Job& right)
    {
        left.swap(right);
    }

    
    struct TestWorkflow
    {
        std::list< ::benchmark::Job> jobs;
        
        TestWorkflow()
        {
        }

        
        // Compiler generated copy ctor OK
        TestWorkflow(const TestWorkflow&) = default;
        
        TestWorkflow(TestWorkflow&&) = default;
        
        
        // Compiler generated operator= OK
        TestWorkflow& operator=(const TestWorkflow&) = default;
        TestWorkflow& operator=(TestWorkflow&&) = default;

        bool operator==(const TestWorkflow& other) const
        {
            return true
                && (jobs == other.jobs);
        }

        bool operator!=(const TestWorkflow& other) const
        {
            return !(*this == other);
        }

        void swap(TestWorkflow& other)
        {
            using std::swap;
            swap(jobs, other.jobs);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::TestWorkflow& left, ::benchmark::TestWorkflow& right)
    {
        left.swap(right);
    }

    
    struct Workflows
    {
        ::benchmark::TestWorkflow test;
        
        Workflows()
        {
        }

        
        // Compiler generated copy ctor OK
        Workflows(const Workflows&) = default;
        
        Workflows(Workflows&&) = default;
        
        
        // Compiler generated operator= OK
        Workflows& operator=(const Workflows&) = default;
        Workflows& operator=(Workflows&&) = default;

        bool operator==(const Workflows& other) const
        {
            return true
                && (test == other.test);
        }

        bool operator!=(const Workflows& other) const
        {
            return !(*this == other);
        }

        void swap(Workflows& other)
        {
            using std::swap;
            swap(test, other.test);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Workflows& left, ::benchmark::Workflows& right)
    {
        left.swap(right);
    }

    
    struct Main
    {
        double version;
        ::benchmark::Workflows workflows;
        
        Main()
          : version()
        {
        }

        
        // Compiler generated copy ctor OK
        Main(const Main&) = default;
        
        Main(Main&&) = default;
        
        
        // Compiler generated operator= OK
        Main& operator=(const Main&) = default;
        Main& operator=(Main&&) = default;

        bool operator==(const Main& other) const
        {
            return true
                && (version == other.version)
                && (workflows == other.workflows);
        }

        bool operator!=(const Main& other) const
        {
            return !(*this == other);
        }

        void swap(Main& other)
        {
            using std::swap;
            swap(version, other.version);
            swap(workflows, other.workflows);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Main& left, ::benchmark::Main& right)
    {
        left.swap(right);
    }
} // namespace benchmark
