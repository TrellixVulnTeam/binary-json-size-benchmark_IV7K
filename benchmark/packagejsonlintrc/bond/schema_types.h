
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.12.1.0
//   Input filename:  benchmark/packagejsonlintrc/bond/schema.bond
//   Output filename: schema_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0902
#error This file was generated by a newer version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0c10
#error This file was generated by an older version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace benchmark
{
    
    struct ComplexRule
    {
        ::bond::maybe<std::string> level;
        ::bond::maybe<std::list<std::string> > options;
        ::bond::maybe<std::list<bool> > booleanOptions;
        
        ComplexRule()
        {
        }

        
        // Compiler generated copy ctor OK
        ComplexRule(const ComplexRule&) = default;
        
        ComplexRule(ComplexRule&&) = default;
        
        
        // Compiler generated operator= OK
        ComplexRule& operator=(const ComplexRule&) = default;
        ComplexRule& operator=(ComplexRule&&) = default;

        bool operator==(const ComplexRule& other) const
        {
            return true
                && (level == other.level)
                && (options == other.options)
                && (booleanOptions == other.booleanOptions);
        }

        bool operator!=(const ComplexRule& other) const
        {
            return !(*this == other);
        }

        void swap(ComplexRule& other)
        {
            using std::swap;
            swap(level, other.level);
            swap(options, other.options);
            swap(booleanOptions, other.booleanOptions);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::ComplexRule& left, ::benchmark::ComplexRule& right)
    {
        left.swap(right);
    }

    
    struct Rules
    {
        std::string requireAuthor;
        std::string requireDescription;
        std::string requireEngines;
        std::string requireLicense;
        std::string requireName;
        std::string requireRepository;
        std::string requireVersion;
        std::string requireBugs;
        std::string requireHomepage;
        std::string requireKeywords;
        std::string binType;
        std::string configType;
        std::string descriptionType;
        std::string devDependenciesType;
        std::string directoriesType;
        std::string enginesType;
        std::string filesType;
        std::string homepageType;
        std::string keywordsType;
        std::string licenseType;
        std::string mainType;
        std::string manType;
        std::string nameType;
        std::string preferGlobalType;
        std::string privateType;
        std::string repositoryType;
        std::string scriptsType;
        std::string versionType;
        std::list< ::benchmark::ComplexRule> validValuesAuthor;
        std::list< ::benchmark::ComplexRule> validValuesPrivate;
        std::list< ::benchmark::ComplexRule> noRestrictedDependencies;
        std::list< ::benchmark::ComplexRule> noRestrictedPreReleaseDependencies;
        std::list< ::benchmark::ComplexRule> noRestrictedInvalidDevDependencies;
        std::list< ::benchmark::ComplexRule> noRestrictedPreReleaseDevDependencies;
        std::string nameFormat;
        std::string versionFormat;
        
        Rules()
        {
        }

        
        // Compiler generated copy ctor OK
        Rules(const Rules&) = default;
        
        Rules(Rules&&) = default;
        
        
        // Compiler generated operator= OK
        Rules& operator=(const Rules&) = default;
        Rules& operator=(Rules&&) = default;

        bool operator==(const Rules& other) const
        {
            return true
                && (requireAuthor == other.requireAuthor)
                && (requireDescription == other.requireDescription)
                && (requireEngines == other.requireEngines)
                && (requireLicense == other.requireLicense)
                && (requireName == other.requireName)
                && (requireRepository == other.requireRepository)
                && (requireVersion == other.requireVersion)
                && (requireBugs == other.requireBugs)
                && (requireHomepage == other.requireHomepage)
                && (requireKeywords == other.requireKeywords)
                && (binType == other.binType)
                && (configType == other.configType)
                && (descriptionType == other.descriptionType)
                && (devDependenciesType == other.devDependenciesType)
                && (directoriesType == other.directoriesType)
                && (enginesType == other.enginesType)
                && (filesType == other.filesType)
                && (homepageType == other.homepageType)
                && (keywordsType == other.keywordsType)
                && (licenseType == other.licenseType)
                && (mainType == other.mainType)
                && (manType == other.manType)
                && (nameType == other.nameType)
                && (preferGlobalType == other.preferGlobalType)
                && (privateType == other.privateType)
                && (repositoryType == other.repositoryType)
                && (scriptsType == other.scriptsType)
                && (versionType == other.versionType)
                && (validValuesAuthor == other.validValuesAuthor)
                && (validValuesPrivate == other.validValuesPrivate)
                && (noRestrictedDependencies == other.noRestrictedDependencies)
                && (noRestrictedPreReleaseDependencies == other.noRestrictedPreReleaseDependencies)
                && (noRestrictedInvalidDevDependencies == other.noRestrictedInvalidDevDependencies)
                && (noRestrictedPreReleaseDevDependencies == other.noRestrictedPreReleaseDevDependencies)
                && (nameFormat == other.nameFormat)
                && (versionFormat == other.versionFormat);
        }

        bool operator!=(const Rules& other) const
        {
            return !(*this == other);
        }

        void swap(Rules& other)
        {
            using std::swap;
            swap(requireAuthor, other.requireAuthor);
            swap(requireDescription, other.requireDescription);
            swap(requireEngines, other.requireEngines);
            swap(requireLicense, other.requireLicense);
            swap(requireName, other.requireName);
            swap(requireRepository, other.requireRepository);
            swap(requireVersion, other.requireVersion);
            swap(requireBugs, other.requireBugs);
            swap(requireHomepage, other.requireHomepage);
            swap(requireKeywords, other.requireKeywords);
            swap(binType, other.binType);
            swap(configType, other.configType);
            swap(descriptionType, other.descriptionType);
            swap(devDependenciesType, other.devDependenciesType);
            swap(directoriesType, other.directoriesType);
            swap(enginesType, other.enginesType);
            swap(filesType, other.filesType);
            swap(homepageType, other.homepageType);
            swap(keywordsType, other.keywordsType);
            swap(licenseType, other.licenseType);
            swap(mainType, other.mainType);
            swap(manType, other.manType);
            swap(nameType, other.nameType);
            swap(preferGlobalType, other.preferGlobalType);
            swap(privateType, other.privateType);
            swap(repositoryType, other.repositoryType);
            swap(scriptsType, other.scriptsType);
            swap(versionType, other.versionType);
            swap(validValuesAuthor, other.validValuesAuthor);
            swap(validValuesPrivate, other.validValuesPrivate);
            swap(noRestrictedDependencies, other.noRestrictedDependencies);
            swap(noRestrictedPreReleaseDependencies, other.noRestrictedPreReleaseDependencies);
            swap(noRestrictedInvalidDevDependencies, other.noRestrictedInvalidDevDependencies);
            swap(noRestrictedPreReleaseDevDependencies, other.noRestrictedPreReleaseDevDependencies);
            swap(nameFormat, other.nameFormat);
            swap(versionFormat, other.versionFormat);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Rules& left, ::benchmark::Rules& right)
    {
        left.swap(right);
    }

    
    struct Main
    {
        ::benchmark::Rules rules;
        
        Main()
        {
        }

        
        // Compiler generated copy ctor OK
        Main(const Main&) = default;
        
        Main(Main&&) = default;
        
        
        // Compiler generated operator= OK
        Main& operator=(const Main&) = default;
        Main& operator=(Main&&) = default;

        bool operator==(const Main& other) const
        {
            return true
                && (rules == other.rules);
        }

        bool operator!=(const Main& other) const
        {
            return !(*this == other);
        }

        void swap(Main& other)
        {
            using std::swap;
            swap(rules, other.rules);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Main& left, ::benchmark::Main& right)
    {
        left.swap(right);
    }
} // namespace benchmark
