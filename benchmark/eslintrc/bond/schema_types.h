
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.12.1.0
//   Input filename:  benchmark/eslintrc/bond/schema.bond
//   Output filename: schema_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0902
#error This file was generated by a newer version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0c10
#error This file was generated by an older version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace benchmark
{
    
    struct EcmaFeatures
    {
        bool jsx;
        
        EcmaFeatures()
          : jsx()
        {
        }

        
        // Compiler generated copy ctor OK
        EcmaFeatures(const EcmaFeatures&) = default;
        
        EcmaFeatures(EcmaFeatures&&) = default;
        
        
        // Compiler generated operator= OK
        EcmaFeatures& operator=(const EcmaFeatures&) = default;
        EcmaFeatures& operator=(EcmaFeatures&&) = default;

        bool operator==(const EcmaFeatures& other) const
        {
            return true
                && (jsx == other.jsx);
        }

        bool operator!=(const EcmaFeatures& other) const
        {
            return !(*this == other);
        }

        void swap(EcmaFeatures& other)
        {
            using std::swap;
            swap(jsx, other.jsx);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::EcmaFeatures& left, ::benchmark::EcmaFeatures& right)
    {
        left.swap(right);
    }

    
    struct Environment
    {
        bool browser;
        bool node;
        bool es6;
        
        Environment()
          : browser(),
            node(),
            es6()
        {
        }

        
        // Compiler generated copy ctor OK
        Environment(const Environment&) = default;
        
        Environment(Environment&&) = default;
        
        
        // Compiler generated operator= OK
        Environment& operator=(const Environment&) = default;
        Environment& operator=(Environment&&) = default;

        bool operator==(const Environment& other) const
        {
            return true
                && (browser == other.browser)
                && (node == other.node)
                && (es6 == other.es6);
        }

        bool operator!=(const Environment& other) const
        {
            return !(*this == other);
        }

        void swap(Environment& other)
        {
            using std::swap;
            swap(browser, other.browser);
            swap(node, other.node);
            swap(es6, other.es6);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Environment& left, ::benchmark::Environment& right)
    {
        left.swap(right);
    }

    
    struct JSDocOptions
    {
        bool requireReturn;
        
        JSDocOptions()
          : requireReturn()
        {
        }

        
        // Compiler generated copy ctor OK
        JSDocOptions(const JSDocOptions&) = default;
        
        JSDocOptions(JSDocOptions&&) = default;
        
        
        // Compiler generated operator= OK
        JSDocOptions& operator=(const JSDocOptions&) = default;
        JSDocOptions& operator=(JSDocOptions&&) = default;

        bool operator==(const JSDocOptions& other) const
        {
            return true
                && (requireReturn == other.requireReturn);
        }

        bool operator!=(const JSDocOptions& other) const
        {
            return !(*this == other);
        }

        void swap(JSDocOptions& other)
        {
            using std::swap;
            swap(requireReturn, other.requireReturn);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::JSDocOptions& left, ::benchmark::JSDocOptions& right)
    {
        left.swap(right);
    }

    
    struct JSDocRule
    {
        uint8_t numeric;
        ::benchmark::JSDocOptions options;
        
        JSDocRule()
          : numeric()
        {
        }

        
        // Compiler generated copy ctor OK
        JSDocRule(const JSDocRule&) = default;
        
        JSDocRule(JSDocRule&&) = default;
        
        
        // Compiler generated operator= OK
        JSDocRule& operator=(const JSDocRule&) = default;
        JSDocRule& operator=(JSDocRule&&) = default;

        bool operator==(const JSDocRule& other) const
        {
            return true
                && (numeric == other.numeric)
                && (options == other.options);
        }

        bool operator!=(const JSDocRule& other) const
        {
            return !(*this == other);
        }

        void swap(JSDocRule& other)
        {
            using std::swap;
            swap(numeric, other.numeric);
            swap(options, other.options);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::JSDocRule& left, ::benchmark::JSDocRule& right)
    {
        left.swap(right);
    }

    
    struct Rules
    {
        uint8_t eqeqeq;
        uint8_t commaDangle;
        uint8_t noConsole;
        uint8_t noDebugger;
        uint8_t noExtraSemi;
        uint8_t noExtraParens;
        uint8_t noIrregularWhitespace;
        uint8_t noUndef;
        uint8_t noUnusedVars;
        uint8_t semi;
        uint8_t semiSpacing;
        std::list< ::benchmark::JSDocRule> validJsdoc;
        uint8_t reactDisplayName;
        uint8_t reactForbidPropTypes;
        uint8_t reactJsxBooleanValue;
        uint8_t reactJsxClosingBracketLocation;
        uint8_t reactJsxCurlySpacing;
        uint8_t reactJsxIndentProps;
        uint8_t reactJsxMaxPropsPerLine;
        uint8_t reactJsxNoDuplicateProps;
        uint8_t reactJsxNoLiterals;
        uint8_t reactJsxNoUndef;
        uint8_t reactJsxSortPropTypes;
        uint8_t reactJsxSortProps;
        uint8_t reactJsxUsesReact;
        uint8_t reactJsxUsesVars;
        uint8_t reactNoDanger;
        uint8_t reactNoDidMountSetState;
        uint8_t reactNoDidUpdateSetState;
        uint8_t reactNoDirectMutationState;
        uint8_t reactNoMultiComp;
        uint8_t reactNoSetState;
        uint8_t reactNoUnknownProperty;
        uint8_t reactPropTypes;
        uint8_t reactReactInJsxScope;
        uint8_t reactRequireExtension;
        uint8_t reactSelfClosingComp;
        uint8_t reactSortComp;
        uint8_t reactWrapMultilines;
        
        Rules()
          : eqeqeq(),
            commaDangle(),
            noConsole(),
            noDebugger(),
            noExtraSemi(),
            noExtraParens(),
            noIrregularWhitespace(),
            noUndef(),
            noUnusedVars(),
            semi(),
            semiSpacing(),
            reactDisplayName(),
            reactForbidPropTypes(),
            reactJsxBooleanValue(),
            reactJsxClosingBracketLocation(),
            reactJsxCurlySpacing(),
            reactJsxIndentProps(),
            reactJsxMaxPropsPerLine(),
            reactJsxNoDuplicateProps(),
            reactJsxNoLiterals(),
            reactJsxNoUndef(),
            reactJsxSortPropTypes(),
            reactJsxSortProps(),
            reactJsxUsesReact(),
            reactJsxUsesVars(),
            reactNoDanger(),
            reactNoDidMountSetState(),
            reactNoDidUpdateSetState(),
            reactNoDirectMutationState(),
            reactNoMultiComp(),
            reactNoSetState(),
            reactNoUnknownProperty(),
            reactPropTypes(),
            reactReactInJsxScope(),
            reactRequireExtension(),
            reactSelfClosingComp(),
            reactSortComp(),
            reactWrapMultilines()
        {
        }

        
        // Compiler generated copy ctor OK
        Rules(const Rules&) = default;
        
        Rules(Rules&&) = default;
        
        
        // Compiler generated operator= OK
        Rules& operator=(const Rules&) = default;
        Rules& operator=(Rules&&) = default;

        bool operator==(const Rules& other) const
        {
            return true
                && (eqeqeq == other.eqeqeq)
                && (commaDangle == other.commaDangle)
                && (noConsole == other.noConsole)
                && (noDebugger == other.noDebugger)
                && (noExtraSemi == other.noExtraSemi)
                && (noExtraParens == other.noExtraParens)
                && (noIrregularWhitespace == other.noIrregularWhitespace)
                && (noUndef == other.noUndef)
                && (noUnusedVars == other.noUnusedVars)
                && (semi == other.semi)
                && (semiSpacing == other.semiSpacing)
                && (validJsdoc == other.validJsdoc)
                && (reactDisplayName == other.reactDisplayName)
                && (reactForbidPropTypes == other.reactForbidPropTypes)
                && (reactJsxBooleanValue == other.reactJsxBooleanValue)
                && (reactJsxClosingBracketLocation == other.reactJsxClosingBracketLocation)
                && (reactJsxCurlySpacing == other.reactJsxCurlySpacing)
                && (reactJsxIndentProps == other.reactJsxIndentProps)
                && (reactJsxMaxPropsPerLine == other.reactJsxMaxPropsPerLine)
                && (reactJsxNoDuplicateProps == other.reactJsxNoDuplicateProps)
                && (reactJsxNoLiterals == other.reactJsxNoLiterals)
                && (reactJsxNoUndef == other.reactJsxNoUndef)
                && (reactJsxSortPropTypes == other.reactJsxSortPropTypes)
                && (reactJsxSortProps == other.reactJsxSortProps)
                && (reactJsxUsesReact == other.reactJsxUsesReact)
                && (reactJsxUsesVars == other.reactJsxUsesVars)
                && (reactNoDanger == other.reactNoDanger)
                && (reactNoDidMountSetState == other.reactNoDidMountSetState)
                && (reactNoDidUpdateSetState == other.reactNoDidUpdateSetState)
                && (reactNoDirectMutationState == other.reactNoDirectMutationState)
                && (reactNoMultiComp == other.reactNoMultiComp)
                && (reactNoSetState == other.reactNoSetState)
                && (reactNoUnknownProperty == other.reactNoUnknownProperty)
                && (reactPropTypes == other.reactPropTypes)
                && (reactReactInJsxScope == other.reactReactInJsxScope)
                && (reactRequireExtension == other.reactRequireExtension)
                && (reactSelfClosingComp == other.reactSelfClosingComp)
                && (reactSortComp == other.reactSortComp)
                && (reactWrapMultilines == other.reactWrapMultilines);
        }

        bool operator!=(const Rules& other) const
        {
            return !(*this == other);
        }

        void swap(Rules& other)
        {
            using std::swap;
            swap(eqeqeq, other.eqeqeq);
            swap(commaDangle, other.commaDangle);
            swap(noConsole, other.noConsole);
            swap(noDebugger, other.noDebugger);
            swap(noExtraSemi, other.noExtraSemi);
            swap(noExtraParens, other.noExtraParens);
            swap(noIrregularWhitespace, other.noIrregularWhitespace);
            swap(noUndef, other.noUndef);
            swap(noUnusedVars, other.noUnusedVars);
            swap(semi, other.semi);
            swap(semiSpacing, other.semiSpacing);
            swap(validJsdoc, other.validJsdoc);
            swap(reactDisplayName, other.reactDisplayName);
            swap(reactForbidPropTypes, other.reactForbidPropTypes);
            swap(reactJsxBooleanValue, other.reactJsxBooleanValue);
            swap(reactJsxClosingBracketLocation, other.reactJsxClosingBracketLocation);
            swap(reactJsxCurlySpacing, other.reactJsxCurlySpacing);
            swap(reactJsxIndentProps, other.reactJsxIndentProps);
            swap(reactJsxMaxPropsPerLine, other.reactJsxMaxPropsPerLine);
            swap(reactJsxNoDuplicateProps, other.reactJsxNoDuplicateProps);
            swap(reactJsxNoLiterals, other.reactJsxNoLiterals);
            swap(reactJsxNoUndef, other.reactJsxNoUndef);
            swap(reactJsxSortPropTypes, other.reactJsxSortPropTypes);
            swap(reactJsxSortProps, other.reactJsxSortProps);
            swap(reactJsxUsesReact, other.reactJsxUsesReact);
            swap(reactJsxUsesVars, other.reactJsxUsesVars);
            swap(reactNoDanger, other.reactNoDanger);
            swap(reactNoDidMountSetState, other.reactNoDidMountSetState);
            swap(reactNoDidUpdateSetState, other.reactNoDidUpdateSetState);
            swap(reactNoDirectMutationState, other.reactNoDirectMutationState);
            swap(reactNoMultiComp, other.reactNoMultiComp);
            swap(reactNoSetState, other.reactNoSetState);
            swap(reactNoUnknownProperty, other.reactNoUnknownProperty);
            swap(reactPropTypes, other.reactPropTypes);
            swap(reactReactInJsxScope, other.reactReactInJsxScope);
            swap(reactRequireExtension, other.reactRequireExtension);
            swap(reactSelfClosingComp, other.reactSelfClosingComp);
            swap(reactSortComp, other.reactSortComp);
            swap(reactWrapMultilines, other.reactWrapMultilines);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Rules& left, ::benchmark::Rules& right)
    {
        left.swap(right);
    }

    
    struct Main
    {
        std::string extends;
        std::string parser;
        ::benchmark::EcmaFeatures ecmaFeatures;
        std::list<std::string> plugins;
        ::benchmark::Environment env;
        ::benchmark::Rules rules;
        
        Main()
        {
        }

        
        // Compiler generated copy ctor OK
        Main(const Main&) = default;
        
        Main(Main&&) = default;
        
        
        // Compiler generated operator= OK
        Main& operator=(const Main&) = default;
        Main& operator=(Main&&) = default;

        bool operator==(const Main& other) const
        {
            return true
                && (extends == other.extends)
                && (parser == other.parser)
                && (ecmaFeatures == other.ecmaFeatures)
                && (plugins == other.plugins)
                && (env == other.env)
                && (rules == other.rules);
        }

        bool operator!=(const Main& other) const
        {
            return !(*this == other);
        }

        void swap(Main& other)
        {
            using std::swap;
            swap(extends, other.extends);
            swap(parser, other.parser);
            swap(ecmaFeatures, other.ecmaFeatures);
            swap(plugins, other.plugins);
            swap(env, other.env);
            swap(rules, other.rules);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Main& left, ::benchmark::Main& right)
    {
        left.swap(right);
    }
} // namespace benchmark
