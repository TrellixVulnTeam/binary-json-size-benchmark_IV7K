
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.12.1.0
//   Input filename:  benchmark/nightwatch/bond/schema.bond
//   Output filename: schema_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0902
#error This file was generated by a newer version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0c10
#error This file was generated by an older version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include <bond/core/nullable.h>


namespace benchmark
{
    
    struct Globals
    {
        bool abortOnAssertionFailure;
        bool abortOnElementLocateError;
        uint16_t waitForConditionPollInterval;
        uint16_t waitForConditionTimeout;
        bool throwOnMultipleElementsReturned;
        bool suppressWarningsOnMultipleElementsReturned;
        uint16_t asyncHookTimeout;
        uint16_t unitTestsTimeout;
        uint16_t customReporterCallbackTimeout;
        uint16_t retryAssertionTimeout;
        
        Globals()
          : abortOnAssertionFailure(),
            abortOnElementLocateError(),
            waitForConditionPollInterval(),
            waitForConditionTimeout(),
            throwOnMultipleElementsReturned(),
            suppressWarningsOnMultipleElementsReturned(),
            asyncHookTimeout(),
            unitTestsTimeout(),
            customReporterCallbackTimeout(),
            retryAssertionTimeout()
        {
        }

        
        // Compiler generated copy ctor OK
        Globals(const Globals&) = default;
        
        Globals(Globals&&) = default;
        
        
        // Compiler generated operator= OK
        Globals& operator=(const Globals&) = default;
        Globals& operator=(Globals&&) = default;

        bool operator==(const Globals& other) const
        {
            return true
                && (abortOnAssertionFailure == other.abortOnAssertionFailure)
                && (abortOnElementLocateError == other.abortOnElementLocateError)
                && (waitForConditionPollInterval == other.waitForConditionPollInterval)
                && (waitForConditionTimeout == other.waitForConditionTimeout)
                && (throwOnMultipleElementsReturned == other.throwOnMultipleElementsReturned)
                && (suppressWarningsOnMultipleElementsReturned == other.suppressWarningsOnMultipleElementsReturned)
                && (asyncHookTimeout == other.asyncHookTimeout)
                && (unitTestsTimeout == other.unitTestsTimeout)
                && (customReporterCallbackTimeout == other.customReporterCallbackTimeout)
                && (retryAssertionTimeout == other.retryAssertionTimeout);
        }

        bool operator!=(const Globals& other) const
        {
            return !(*this == other);
        }

        void swap(Globals& other)
        {
            using std::swap;
            swap(abortOnAssertionFailure, other.abortOnAssertionFailure);
            swap(abortOnElementLocateError, other.abortOnElementLocateError);
            swap(waitForConditionPollInterval, other.waitForConditionPollInterval);
            swap(waitForConditionTimeout, other.waitForConditionTimeout);
            swap(throwOnMultipleElementsReturned, other.throwOnMultipleElementsReturned);
            swap(suppressWarningsOnMultipleElementsReturned, other.suppressWarningsOnMultipleElementsReturned);
            swap(asyncHookTimeout, other.asyncHookTimeout);
            swap(unitTestsTimeout, other.unitTestsTimeout);
            swap(customReporterCallbackTimeout, other.customReporterCallbackTimeout);
            swap(retryAssertionTimeout, other.retryAssertionTimeout);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Globals& left, ::benchmark::Globals& right)
    {
        left.swap(right);
    }

    
    struct Empty
    {
        
        Empty()
        {
        }

        
        // Compiler generated copy ctor OK
        Empty(const Empty&) = default;
        
        Empty(Empty&&) = default;
        
        
        // Compiler generated operator= OK
        Empty& operator=(const Empty&) = default;
        Empty& operator=(Empty&&) = default;

        bool operator==(const Empty&) const
        {
            return true;
        }

        bool operator!=(const Empty& other) const
        {
            return !(*this == other);
        }

        void swap(Empty&)
        {
            using std::swap;
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Empty& left, ::benchmark::Empty& right)
    {
        left.swap(right);
    }

    
    struct Selenium
    {
        bool start_process;
        ::benchmark::Empty cli_args;
        ::bond::nullable<std::string> server_path;
        std::string log_path;
        uint16_t check_process_delay;
        uint8_t max_status_poll_tries;
        uint8_t status_poll_interval;
        
        Selenium()
          : start_process(),
            check_process_delay(),
            max_status_poll_tries(),
            status_poll_interval()
        {
        }

        
        // Compiler generated copy ctor OK
        Selenium(const Selenium&) = default;
        
        Selenium(Selenium&&) = default;
        
        
        // Compiler generated operator= OK
        Selenium& operator=(const Selenium&) = default;
        Selenium& operator=(Selenium&&) = default;

        bool operator==(const Selenium& other) const
        {
            return true
                && (start_process == other.start_process)
                && (cli_args == other.cli_args)
                && (server_path == other.server_path)
                && (log_path == other.log_path)
                && (check_process_delay == other.check_process_delay)
                && (max_status_poll_tries == other.max_status_poll_tries)
                && (status_poll_interval == other.status_poll_interval);
        }

        bool operator!=(const Selenium& other) const
        {
            return !(*this == other);
        }

        void swap(Selenium& other)
        {
            using std::swap;
            swap(start_process, other.start_process);
            swap(cli_args, other.cli_args);
            swap(server_path, other.server_path);
            swap(log_path, other.log_path);
            swap(check_process_delay, other.check_process_delay);
            swap(max_status_poll_tries, other.max_status_poll_tries);
            swap(status_poll_interval, other.status_poll_interval);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Selenium& left, ::benchmark::Selenium& right)
    {
        left.swap(right);
    }

    
    struct WebDriver
    {
        bool start_process;
        ::benchmark::Empty cli_args;
        ::bond::nullable<std::string> server_path;
        std::string log_path;
        uint8_t check_process_delay;
        uint8_t max_status_poll_tries;
        uint8_t status_poll_interval;
        uint32_t process_create_timeout;
        ::benchmark::Empty timeout_options;
        
        WebDriver()
          : start_process(),
            check_process_delay(),
            max_status_poll_tries(),
            status_poll_interval(),
            process_create_timeout()
        {
        }

        
        // Compiler generated copy ctor OK
        WebDriver(const WebDriver&) = default;
        
        WebDriver(WebDriver&&) = default;
        
        
        // Compiler generated operator= OK
        WebDriver& operator=(const WebDriver&) = default;
        WebDriver& operator=(WebDriver&&) = default;

        bool operator==(const WebDriver& other) const
        {
            return true
                && (start_process == other.start_process)
                && (cli_args == other.cli_args)
                && (server_path == other.server_path)
                && (log_path == other.log_path)
                && (check_process_delay == other.check_process_delay)
                && (max_status_poll_tries == other.max_status_poll_tries)
                && (status_poll_interval == other.status_poll_interval)
                && (process_create_timeout == other.process_create_timeout)
                && (timeout_options == other.timeout_options);
        }

        bool operator!=(const WebDriver& other) const
        {
            return !(*this == other);
        }

        void swap(WebDriver& other)
        {
            using std::swap;
            swap(start_process, other.start_process);
            swap(cli_args, other.cli_args);
            swap(server_path, other.server_path);
            swap(log_path, other.log_path);
            swap(check_process_delay, other.check_process_delay);
            swap(max_status_poll_tries, other.max_status_poll_tries);
            swap(status_poll_interval, other.status_poll_interval);
            swap(process_create_timeout, other.process_create_timeout);
            swap(timeout_options, other.timeout_options);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::WebDriver& left, ::benchmark::WebDriver& right)
    {
        left.swap(right);
    }

    
    struct DesiredCapabilities
    {
        std::string browserName;
        
        DesiredCapabilities()
        {
        }

        
        // Compiler generated copy ctor OK
        DesiredCapabilities(const DesiredCapabilities&) = default;
        
        DesiredCapabilities(DesiredCapabilities&&) = default;
        
        
        // Compiler generated operator= OK
        DesiredCapabilities& operator=(const DesiredCapabilities&) = default;
        DesiredCapabilities& operator=(DesiredCapabilities&&) = default;

        bool operator==(const DesiredCapabilities& other) const
        {
            return true
                && (browserName == other.browserName);
        }

        bool operator!=(const DesiredCapabilities& other) const
        {
            return !(*this == other);
        }

        void swap(DesiredCapabilities& other)
        {
            using std::swap;
            swap(browserName, other.browserName);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::DesiredCapabilities& left, ::benchmark::DesiredCapabilities& right)
    {
        left.swap(right);
    }

    
    struct Main
    {
        ::bond::nullable<std::string> custom_commands_path;
        ::bond::nullable<std::string> custom_assertions_path;
        ::bond::nullable<std::string> page_objects_path;
        ::bond::nullable<std::string> globals_path;
        ::benchmark::Globals globals;
        ::benchmark::Empty dotenv;
        bool persist_globals;
        std::string output_folder;
        ::bond::nullable<std::string> src_folders;
        bool live_output;
        bool disable_colors;
        uint8_t parallel_process_delay;
        ::benchmark::Selenium selenium;
        bool start_session;
        bool end_session_on_fail;
        bool test_workers;
        std::string test_runner;
        ::benchmark::WebDriver webdriver;
        ::benchmark::Empty test_settings;
        std::string launch_url;
        bool silent;
        bool output;
        bool detailed_output;
        bool output_timestamp;
        bool disable_error_log;
        bool screenshots;
        bool log_screenshot_data;
        ::benchmark::DesiredCapabilities desiredCapabilities;
        ::bond::nullable<std::string> exclude;
        ::bond::nullable<std::string> filter;
        std::string skipgroup;
        bool sync_test_names;
        std::string skiptags;
        bool use_xpath;
        bool parallel_mode;
        std::string report_prefix;
        bool unit_tests_mode;
        std::string default_reporter;
        
        Main()
          : persist_globals(),
            live_output(),
            disable_colors(),
            parallel_process_delay(),
            start_session(),
            end_session_on_fail(),
            test_workers(),
            silent(),
            output(),
            detailed_output(),
            output_timestamp(),
            disable_error_log(),
            screenshots(),
            log_screenshot_data(),
            sync_test_names(),
            use_xpath(),
            parallel_mode(),
            unit_tests_mode()
        {
        }

        
        // Compiler generated copy ctor OK
        Main(const Main&) = default;
        
        Main(Main&&) = default;
        
        
        // Compiler generated operator= OK
        Main& operator=(const Main&) = default;
        Main& operator=(Main&&) = default;

        bool operator==(const Main& other) const
        {
            return true
                && (custom_commands_path == other.custom_commands_path)
                && (custom_assertions_path == other.custom_assertions_path)
                && (page_objects_path == other.page_objects_path)
                && (globals_path == other.globals_path)
                && (globals == other.globals)
                && (dotenv == other.dotenv)
                && (persist_globals == other.persist_globals)
                && (output_folder == other.output_folder)
                && (src_folders == other.src_folders)
                && (live_output == other.live_output)
                && (disable_colors == other.disable_colors)
                && (parallel_process_delay == other.parallel_process_delay)
                && (selenium == other.selenium)
                && (start_session == other.start_session)
                && (end_session_on_fail == other.end_session_on_fail)
                && (test_workers == other.test_workers)
                && (test_runner == other.test_runner)
                && (webdriver == other.webdriver)
                && (test_settings == other.test_settings)
                && (launch_url == other.launch_url)
                && (silent == other.silent)
                && (output == other.output)
                && (detailed_output == other.detailed_output)
                && (output_timestamp == other.output_timestamp)
                && (disable_error_log == other.disable_error_log)
                && (screenshots == other.screenshots)
                && (log_screenshot_data == other.log_screenshot_data)
                && (desiredCapabilities == other.desiredCapabilities)
                && (exclude == other.exclude)
                && (filter == other.filter)
                && (skipgroup == other.skipgroup)
                && (sync_test_names == other.sync_test_names)
                && (skiptags == other.skiptags)
                && (use_xpath == other.use_xpath)
                && (parallel_mode == other.parallel_mode)
                && (report_prefix == other.report_prefix)
                && (unit_tests_mode == other.unit_tests_mode)
                && (default_reporter == other.default_reporter);
        }

        bool operator!=(const Main& other) const
        {
            return !(*this == other);
        }

        void swap(Main& other)
        {
            using std::swap;
            swap(custom_commands_path, other.custom_commands_path);
            swap(custom_assertions_path, other.custom_assertions_path);
            swap(page_objects_path, other.page_objects_path);
            swap(globals_path, other.globals_path);
            swap(globals, other.globals);
            swap(dotenv, other.dotenv);
            swap(persist_globals, other.persist_globals);
            swap(output_folder, other.output_folder);
            swap(src_folders, other.src_folders);
            swap(live_output, other.live_output);
            swap(disable_colors, other.disable_colors);
            swap(parallel_process_delay, other.parallel_process_delay);
            swap(selenium, other.selenium);
            swap(start_session, other.start_session);
            swap(end_session_on_fail, other.end_session_on_fail);
            swap(test_workers, other.test_workers);
            swap(test_runner, other.test_runner);
            swap(webdriver, other.webdriver);
            swap(test_settings, other.test_settings);
            swap(launch_url, other.launch_url);
            swap(silent, other.silent);
            swap(output, other.output);
            swap(detailed_output, other.detailed_output);
            swap(output_timestamp, other.output_timestamp);
            swap(disable_error_log, other.disable_error_log);
            swap(screenshots, other.screenshots);
            swap(log_screenshot_data, other.log_screenshot_data);
            swap(desiredCapabilities, other.desiredCapabilities);
            swap(exclude, other.exclude);
            swap(filter, other.filter);
            swap(skipgroup, other.skipgroup);
            swap(sync_test_names, other.sync_test_names);
            swap(skiptags, other.skiptags);
            swap(use_xpath, other.use_xpath);
            swap(parallel_mode, other.parallel_mode);
            swap(report_prefix, other.report_prefix);
            swap(unit_tests_mode, other.unit_tests_mode);
            swap(default_reporter, other.default_reporter);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::benchmark::Main& left, ::benchmark::Main& right)
    {
        left.swap(right);
    }
} // namespace benchmark
